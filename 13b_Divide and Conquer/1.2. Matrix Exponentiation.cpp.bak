/* D&C Prob. #1.2. Matrix Exponentiation = A^n
Given a square matrix A (r x r) and power n find A raised to the power n i.e. A^n.
This problem could be solve using two methods
1. Linear multiplication: R.T. = O(r^3.n) i.e. biquadratic time
2. Divide and Conquer (Fast exponentiation): R.T. = O(r^3.log2(n)) i.e. log-cubic time
[#IMP] Just replace multiplication of two numbers by multiplication of two matrices.
*/

//	Method 2.1. Divide and Conquer (Fast exponentiation) - Recursive (Prefer this over iterative)
//	Running time = O(r^3*log2n) i.e. log-cubic time hence faster than biquadratic solution
//	Auxiliary space = O(r^2) due to the temp matrices if recursion stack is not considered else O(r^2*log2n)

#include<iostream>
#include<vector>
using namespace std;

void printMat(vector<vector<int>> mat) {
    for(int i=0; i<mat.size(); i++) {
        for(int j=0; j<mat[0].size(); j++) cout<<mat[i][j]<<" ";
        cout<<"\n";
    }
}

vector<vector<int>> multiply(vector<vector<int>> A, vector<vector<int>> B) {
    int n = A.size(), m = A[0].size(), x = B.size(), y = B[0].size();
    vector<vector<int>> ans(n, vector<int>(y, 0));				//	multiplication only occurs when m == x and dim of ans becomes n x y
    for(int i=0; i<n; i++) {
        for(int j=0; j<y; j++) {
            for(int k=0; k<m; k++) {							//	m == x
                ans[i][j] += A[i][k]*B[k][j];
            }
        }
    }
    return ans;
}

vector<vector<int>> identityMatrix(int n) {                     //  A square matrix raised to power 0 is an identity matrix
    vector<vector<int>> ideM(n, vector<int>(n, 0));             //  i.e. A^0 = I
    for(int i=0; i<n; i++) ideM[i][i] = 1;
    return ideM;
}

vector<vector<int>> pow(vector<vector<int>> A, int n) {			//	int pow(int x, int n) {
    if(n==0) return identityMatrix(A.size());                   //	    if(n==0) return 1;
    vector<vector<int>> B = pow(A, n/2);                        //	    int y = pow(x, n/2);
    if(n%2==1) return multiply(A, multiply(B, B));              //	    if(n%2==1) return x*y*y;
    else return multiply(B, B);                                 //	    else return y*y;
}                                                               //	}

int main() {
    int r, n;
    cin>>r>>n;
    vector<vector<int>> A(r, vector<int>(r));
    for(int i=0; i<r; i++)
        for(int j=0; j<r; j++) cin>>A[i][j];
    vector<vector<int>> powA_n = pow(A, n);
    cout<<"The matrix A raised to the power "<<n<<" is:\n";
    printMat(powA_n);
}

/* Sample input
3 2
2 4 1
5 9 6
3 7 8

4 5
7 2 -1 -5
2 -3 6 4
3 5 9 8
-1 -3 3 2
*/

//	Method 2.2. Divide and Conquer (Fast exponentiation) - Iterative (Bit trickier to understand)
//	Running time = O(r^3*log2n) i.e. log-cubic time hence faster than biquadratic solution
//	Auxiliary space = O(r^2) due to the temp matrices if recursion stack is not considered else O(r^2*log2n)
/*
######### Incomplete #########

#include <iostream>
using namespace std;

int pow(int x, int n) {
    int res = 1;
	while(n) {
		if(n&1) res = res*x;
		n = n>>1;
		x = x*x;				//	This is the important part that in each iteration we are squaring curr x and storing it in x
	}
	return res;
}

int main() {
    int x, n;
    cin>>x>>n;
    cout<<pow(x, n);
}

//	Method 1. Linear multiplication
//	Running time = O(r^3*n) i.e. biquadratic time
//	Auxiliary space = O(r^2) i.e. due to the resulting matrix

######### Incomplete #########

#include <iostream>
using namespace std;

int main() {
    int x, n;
    cin>>x>>n;
    int ans=1;		//	This takes care of the case when n==0
    while(n--)
    	ans *= x;
    cout<<ans;
    return 0;
}
*/
